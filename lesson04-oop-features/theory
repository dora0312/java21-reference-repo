1.Tính chất đóng gói(encapsulation)
 +) Khái niệm:Tính chất đóng gói được thực hiện qua các từ khóa của access modifier
  (public, private, protected)
  
  Sử dụng: attribute(global variable), method(function)
  		   type(class, interface, abstract class, enum) 
 
  +) private: Đóng gói trong phạm vi của class
  +) public: Sử dụng mọi nơi
  +) default"   ": Đóng gói trong phạm vi của package
  +) protected: Đóng gói trong phạm vi của package
  				Và những class có quan hệ cha/con bên trong package
  				(Tính chất thừa kế: inheritance)
 
2. Đa hình - Polymorphism
 -) Khai niệm:
  Tính chất đa hình có 2 loại: phương thức & đối tướng
  +)Đa hình trong phương thức:
	  Là một phương thức nhưng mà sẽ có nhiều phần thực thi, thể hiện khác nhau.
	  .Overloading
	   --> 2 hay nhiều phương thức được gọi là overrload nếu:
	      +) Cùng 1 type(class), cùng tên hàm
	      +) Khác nhau: 
	         .Kiểu dữ liệu truyền vào của tham số
	         .Số lượng tham số truyền vào
	      (*): Nếu cùng tên, cùng tham số nhưng khác type trả ra thì ko được gọi là Overloading

	  .Overriding
		--> Khi có 1 hàm trong class cha, hàm đó được định nghĩa lại trong class con
		(Liên quan đến tính chất thừa kế)
		Hàm override trong lớp con bắt buộc phải chung phần khai báo với hàm ở lớp cha
		void log() { // declaration
			// Implementation
		}
		
		=> Tại sao phải override hàm cha?
		   Code chung để kế thừa
		   Dù định nghĩa khác nhau nhưng nên override từ cha để thể hiện tính đồng nhất
		vd:
		 Shape
		     calS(){}
		 Rectangle: callS()  <=> tinhS
		 Square   : callS()  <=> callSOfSqure
		 Triangle : callS()  <=> ...
		 Circle   : callS()  <=> ...

  +)Đa hình trong đối tượng:
   Câu hỏi 1: Parent p =  new Child(); 
   			 Mình có thể lấy Child p = new Parent() có được không ?
   			 --> Không, khi biến thuộc child gọi hàm tự tạo ra lúc runtime không thể tìm thấy được trong đối tượng KDL cha
   			 --> Biến KDL cha có thể nhận giá trị KDL chính nó hoặc con
   			 => Vì khi new cha() thì trên Head chỉ tạo ra hàm của cha thôi.
   			    nên khi gọi hàm con sẽ bị lỗi vì trên vùng nhớ Heap của cha không có hàm con.
   			    => thực hiện failed first
  Câu hỏi 2: Tại sao không khai báo trực tiếp
  			 Parent p = new Parent();
  			 Child c = new Child();
  			 mà phải sử dụng đa hình trong đối tượng
  			 Parent p = new Child();
  			-->	Dễ dàng covert KDL qua lại giữa các Child trong phạm vi KDL cha con
  			--> Hỗ trợ tạo một danh sách(mảng) các phần tử trong phạm vi cha con
  			--> Hỗ trợ tạo hàm có KDL cha => có thể truyền tham số KDL cha hoặc con
  			---> Hỗ trợ factory pattern
  			
 3. Tính chất thừa kế
  + Lớp cha là class
    khi: có các thuộc tính chung
    --> Con: Không bắt buộc phải override hàm từ cha
 
  + Lớp cha là interface:
    Khi: Có các hàm chung chưa biết phần thực thi như nào.
    
    Trước java8: Interface chỉ chứa hàm trừu tượng
    --> Con: bắt buộc override hàm trừu tượng từ cha
    
    Từ java 8 trở đi: default, static hàm có thể có body
    java 9: private 
    ==> Nếu các class cha có cùng một hàm thì bắt buộc con phải Override
    
    
    Class<Con> extends class<Cha>
    Class<Con> implements Interface1<Cha>
    Class<Con> implements Interface1<Cha>, Interface2<Cha>
    
    <Abstract>Class extends [Abstract] Class
    [Abstract]Class implements Interface[s]
    
    Interface extends Interface[s]
    
    Abstract class implements Interface hoặc Interface extends Interface
    --> Không bắt buộc phải override abstract method
   
   
?? Java có hỗ trợ đa thừa kế không ? vì sao ?
	Đa thừ kế --> Class con kế thừa thừ nhiều class cha
	==>Nếu con extends nhiều lớp cha, mà con không Override lại hàm của các cha thì khi thực thi con thì không biết
	sẽ thực thi hàm cha nào của nào
	====> Java không hỗ trợ đa thừa kế
		  Vì có trường các class cha có chung hàm khai bóa
		  Nếu Class con không bắt buộc override hàm từ cha
		  --->Thì khi lấy con gọi hàm chung thì sẽ không biết gọi đến class nào
		      compile error thay vì đợi gọi
	
